# directories options
setopt AUTO_CD
setopt AUTO_PUSHD
setopt PUSHD_IGNORE_DUPS
setopt PUSHD_SILENT
setopt PUSHD_TO_HOME

# history
HISTSIZE=9999
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_DUPS
setopt HIST_REDUCE_BLANKS
setopt HIST_SAVE_NO_DUPS
setopt INC_APPEND_HISTORY

# I/O
unsetopt CLOBBER # so we can '>' to truncate existing file

# globbing
setopt EXTENDED_GLOB

# scripts
setopt MULTIOS # so we can: `$ echo 'foo' > file1 > file2`

# zle
bindkey -e
bindkey "^[^[[D" backward-word         # alt-left
bindkey "^[^[[C" forward-word          # alt-right
bindkey "^[^?" backward-kill-word      # alt-backspace
bindkey "^[[3~" delete-char            # delete
bindkey "^[3;5~" delete-char           # delete

# aliases
alias cat="bat"
alias grep="grep --color=auto"
alias less="less -R"
# alias ls="ls -HFG"
# alias ll="ls -lh"
# alias la="ll -A"
# alias sl="ls"
alias l="exa -a1" # short for "1"line "A"ll
alias ls="exa -F" # with suffixes (/ for dirs, ect.)
alias sl="exa -F" # for typos
alias ll="exa -lF --git" # full
alias la="exa -alF --git" # full with hidden files
alias lt="exa -a --tree" # tree
alias lt1="exa -a --tree -L1" # tree level 1
alias lt2="exa -a --tree -L2" # tree level 2
alias llt="exa -a --tree" # long tree
alias llt1="exa -a --tree -L1" # long tree level 1
alias llt2="exa -a --tree -L2" # long tree level 2
alias lr="exa -R" # recurse

alias df="df -kh"
alias man="LC_ALL=C LANG=C man"

# safe
alias cp="cp -i"
alias ln="ln -i"
alias mv="mv -i"
alias rm="rm -i"

# prompt
PS1_EMOJIS=("ðŸ˜€" "ðŸ˜" "ðŸ˜‚" "ðŸ¤£" "ðŸ˜ƒ" "ðŸ˜„" "ðŸ˜…" "ðŸ˜†" "ðŸ˜‰" "ðŸ˜Š" "ðŸ˜‹" "ðŸ˜Ž" "ðŸ˜" "ðŸ˜˜" "ðŸ¥°" "ðŸ˜—" "ðŸ˜™" "ðŸ˜š" "â˜ºï¸" "ðŸ™‚" "ðŸ¤—" "ðŸ¤©" "ðŸ¤”" "ðŸ¤¨" "ðŸ˜" "ðŸ˜‘" "ðŸ˜¶" "ðŸ™„" "ðŸ˜" "ðŸ˜£" "ðŸ˜¥" "ðŸ˜®" "ðŸ¤" "ðŸ˜¯" "ðŸ˜ª" "ðŸ˜«" "ðŸ˜´" "ðŸ˜Œ" "ðŸ˜›" "ðŸ˜œ" "ðŸ˜" "ðŸ¤¤" "ðŸ˜’" "ðŸ˜“" "ðŸ˜”" "ðŸ˜•" "ðŸ™ƒ" "ðŸ¤‘" "ðŸ˜²" "â˜¹ï¸" "ðŸ™" "ðŸ˜–" "ðŸ˜ž" "ðŸ˜Ÿ" "ðŸ˜¤" "ðŸ˜¢" "ðŸ˜­" "ðŸ˜¦" "ðŸ˜§" "ðŸ˜¨" "ðŸ˜©" "ðŸ¤¯" "ðŸ˜¬" "ðŸ˜°" "ðŸ˜±" "ðŸ¥µ" "ðŸ¥¶" "ðŸ˜³" "ðŸ¤ª" "ðŸ˜µ" "ðŸ˜¡" "ðŸ˜ " "ðŸ¤¬" "ðŸ˜·" "ðŸ¤’" "ðŸ¤•" "ðŸ¤¢" "ðŸ¤®" "ðŸ¤§" "ðŸ˜‡" "ðŸ¤ " "ðŸ¤¡" "ðŸ¥³" "ðŸ¥´" "ðŸ¥º" "ðŸ¤¥" "ðŸ¤«" "ðŸ¤­" "ðŸ§" "ðŸ¤“" "ðŸ˜ˆ" "ðŸ‘¿" "ðŸ‘¹" "ðŸ‘º" "ðŸ’€" "ðŸ‘»" "ðŸ‘½" "ðŸ¤–" "ðŸ’©")
NUMBER_OF_EMOJIS=${#PS1_EMOJIS[@]}

setopt PROMPT_SUBST
prompt_status() {
  echo -n "%(?.%F{green}.%F{red})â— %f"
}
prompt_user() {
  if [[ $UID -eq 0 ]]; then
    echo -n "%K{red}%F{white}root %k%f"
  fi
}
prompt_dir() {
  # colors for the prompt at https://framagit.org/mpo/dotfiles/blob/0fbc8e070793f060b90690fb99d526e8f94fd8ad/zsh/.zsh-color-names
  # part of shrink path stolen from https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/shrink-path/shrink-path.plugin.zsh
  echo -n "%F{green}"
  echo -n $(pwd | perl -pe "
   BEGIN {
      binmode STDIN,  ':encoding(UTF-8)';
      binmode STDOUT, ':encoding(UTF-8)';
    }; s|^$HOME|~|g; s|/([^/])[^/]*(?=/)|/\$1|g
  ")
  echo -n " %f"
}
prompt_git() {
  local repo git_status ref
  # repo=$(git rev-parse --git-dir 2>/dev/null)
  if $(git rev-parse --is-inside-work-tree >/dev/null 2>&1); then
    ref=$(git symbolic-ref HEAD 2> /dev/null) || ref=$(git show-ref --head -s --abbrev |head -n1 2> /dev/null)
    echo -n "%F{magenta}â¤ž ${ref/refs\/heads\//}"
    git_status=$(git status --porcelain 2> /dev/null | tail -n1)
    if [[ -n $git_status ]]; then
      echo -n "*"
    fi
    echo -n " %f"
  fi
}
PROMPT='
%{%f%b%k%}$(prompt_status)${PS1_EMOJIS[$RANDOM % $NUMBER_OF_EMOJIS]} $(prompt_user)$(prompt_dir)$(prompt_git)\$ '
RPROMPT='%*'

# utils
## https://github.com/wting/autojump
[ -f `brew --prefix`/etc/profile.d/autojump.sh ] && . `brew --prefix`/etc/profile.d/autojump.sh


# completions
setopt ALWAYS_TO_END # cursor to end of the word
setopt PATH_DIRS # search even if there is a slash (i.e. : useful for `bin/cons<tab>`)
setopt AUTO_MENU # when i smash <tab>, you have to show me the completions, FAST
setopt AUTO_PARAM_SLASH # if the completion is a dir, add the trailing slash
setopt AUTO_REMOVE_SLASH
setopt AUTO_LIST # automatically list choices on ambiguous completion.
unsetopt MENU_COMPLETE # do not pick automatically the first completion

fpath=($(brew --prefix)/share/zsh-completions $fpath)

autoload -Uz compinit
_comp_files=($HOME/.zcompdump(Nm-20)) # 20 hours of cache on completions
if (( $#_comp_files )); then
  compinit -i -C
else
  compinit -i
fi
unset _comp_files

zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' # case insensitive
zstyle ':completion::complete:*' use-cache on
zstyle ':completion::complete:*' cache-path $HOME/.zcompcache

if [[ -f $HOME/.github_token ]]; then
  export GITHUB_TOKEN=$(cat $HOME/.github_token)
fi

# include other zshrc
source "${0:A:h}/../docker/docker.zsh" # $0:A is current file path in zsh (including symlink) (:h gives us the directory)

# fancy
alias szs='source ~/.zshrc'
alias h='history -iD'
alias fuck='sudo $(history -p \!\!)'
alias git=hub

export LANG="en_US.UTF-8"
export LC_ALL="en_US.UTF-8"
export PATH="/Users/nyalab/.gem/ruby/2.6.0/bin:/usr/local/opt/openssl@1.1/bin:/usr/local/sbin:$PATH:`yarn global bin`"
