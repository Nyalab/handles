# directories options
setopt AUTO_CD
setopt AUTO_PUSHD
setopt PUSHD_IGNORE_DUPS
setopt PUSHD_SILENT
setopt PUSHD_TO_HOME

# history
HISTSIZE=9999
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_DUPS
setopt HIST_REDUCE_BLANKS
setopt HIST_SAVE_NO_DUPS
setopt INC_APPEND_HISTORY

# I/O
unsetopt CLOBBER # so we can '>' to truncate existing file

# globbing
setopt EXTENDED_GLOB

# scripts
setopt MULTIOS # so we can: `$ echo 'foo' > file1 > file2`

# zle
bindkey -e
bindkey "^[^[[D" backward-word         # alt-left
bindkey "^[^[[C" forward-word          # alt-right
bindkey "^[^?" backward-kill-word      # alt-backspace
bindkey "^[[3~" delete-char            # delete
bindkey "^[3;5~" delete-char           # delete

# aliases
alias cat="bat"
alias grep="grep --color=auto"
alias less="less -R"
# alias ls="ls -HFG"
# alias ll="ls -lh"
# alias la="ll -A"
# alias sl="ls"
alias l="exa -a1" # short for "1"line "A"ll
alias ls="exa -F" # with suffixes (/ for dirs, ect.)
alias sl="exa -F" # for typos
alias ll="exa -lF --git" # full
alias la="exa -alF --git" # full with hidden files
alias lt="exa -a --tree" # tree
alias lt1="exa -a --tree -L1" # tree level 1
alias lt2="exa -a --tree -L2" # tree level 2
alias llt="exa -a --tree" # long tree
alias llt1="exa -a --tree -L1" # long tree level 1
alias llt2="exa -a --tree -L2" # long tree level 2
alias lr="exa -R" # recurse

alias df="df -kh"
alias man="LC_ALL=C LANG=C man"

# safe
alias cp="cp -i"
alias ln="ln -i"
alias mv="mv -i"
alias rm="rm -i"

# prompt
PS1_EMOJIS=("😀" "😁" "😂" "🤣" "😃" "😄" "😅" "😆" "😉" "😊" "😋" "😎" "😍" "😘" "🥰" "😗" "😙" "😚" "☺️" "🙂" "🤗" "🤩" "🤔" "🤨" "😐" "😑" "😶" "🙄" "😏" "😣" "😥" "😮" "🤐" "😯" "😪" "😫" "😴" "😌" "😛" "😜" "😝" "🤤" "😒" "😓" "😔" "😕" "🙃" "🤑" "😲" "☹️" "🙁" "😖" "😞" "😟" "😤" "😢" "😭" "😦" "😧" "😨" "😩" "🤯" "😬" "😰" "😱" "🥵" "🥶" "😳" "🤪" "😵" "😡" "😠" "🤬" "😷" "🤒" "🤕" "🤢" "🤮" "🤧" "😇" "🤠" "🤡" "🥳" "🥴" "🥺" "🤥" "🤫" "🤭" "🧐" "🤓" "😈" "👿" "👹" "👺" "💀" "👻" "👽" "🤖" "💩")
NUMBER_OF_EMOJIS=${#PS1_EMOJIS[@]}

setopt PROMPT_SUBST
prompt_status() {
  echo -n "%(?.%F{green}.%F{red})● %f"
}
prompt_user() {
  if [[ $UID -eq 0 ]]; then
    echo -n "%K{red}%F{white}root %k%f"
  fi
}
prompt_dir() {
  # colors for the prompt at https://framagit.org/mpo/dotfiles/blob/0fbc8e070793f060b90690fb99d526e8f94fd8ad/zsh/.zsh-color-names
  # part of shrink path stolen from https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/shrink-path/shrink-path.plugin.zsh
  echo -n "%F{green}"
  echo -n $(pwd | perl -pe "
   BEGIN {
      binmode STDIN,  ':encoding(UTF-8)';
      binmode STDOUT, ':encoding(UTF-8)';
    }; s|^$HOME|~|g; s|/([^/])[^/]*(?=/)|/\$1|g
  ")
  echo -n " %f"
}
prompt_git() {
  local repo git_status ref
  # repo=$(git rev-parse --git-dir 2>/dev/null)
  if $(git rev-parse --is-inside-work-tree >/dev/null 2>&1); then
    ref=$(git symbolic-ref HEAD 2> /dev/null) || ref=$(git show-ref --head -s --abbrev |head -n1 2> /dev/null)
    echo -n "%F{magenta}⤞ ${ref/refs\/heads\//}"
    git_status=$(git status --porcelain 2> /dev/null | tail -n1)
    if [[ -n $git_status ]]; then
      echo -n "*"
    fi
    echo -n " %f"
  fi
}
PROMPT='
%{%f%b%k%}$(prompt_status)${PS1_EMOJIS[$RANDOM % $NUMBER_OF_EMOJIS]} $(prompt_user)$(prompt_dir)$(prompt_git)\$ '
RPROMPT='%*'

# utils
## https://github.com/wting/autojump
[ -f `brew --prefix`/etc/profile.d/autojump.sh ] && . `brew --prefix`/etc/profile.d/autojump.sh


# completions
setopt ALWAYS_TO_END # cursor to end of the word
setopt PATH_DIRS # search even if there is a slash (i.e. : useful for `bin/cons<tab>`)
setopt AUTO_MENU # when i smash <tab>, you have to show me the completions, FAST
setopt AUTO_PARAM_SLASH # if the completion is a dir, add the trailing slash
setopt AUTO_REMOVE_SLASH
setopt AUTO_LIST # automatically list choices on ambiguous completion.
unsetopt MENU_COMPLETE # do not pick automatically the first completion

fpath=($(brew --prefix)/share/zsh-completions $fpath)

autoload -Uz compinit
_comp_files=($HOME/.zcompdump(Nm-20)) # 20 hours of cache on completions
if (( $#_comp_files )); then
  compinit -i -C
else
  compinit -i
fi
unset _comp_files

zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' # case insensitive
zstyle ':completion::complete:*' use-cache on
zstyle ':completion::complete:*' cache-path $HOME/.zcompcache

if [[ -f $HOME/.github_token ]]; then
  export GITHUB_TOKEN=$(cat $HOME/.github_token)
fi

# include other zshrc
source "${0:A:h}/../docker/docker.zsh" # $0:A is current file path in zsh (including symlink) (:h gives us the directory)

# fancy
alias szs='source ~/.zshrc'
alias h='history -iD'
alias fuck='sudo $(history -p \!\!)'
alias git=hub

export LANG="en_US.UTF-8"
export LC_ALL="en_US.UTF-8"
export PATH="/Users/nyalab/.gem/ruby/2.6.0/bin:/usr/local/opt/openssl@1.1/bin:/usr/local/sbin:$PATH:`yarn global bin`"
